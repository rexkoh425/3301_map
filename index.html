<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Indoor Map Editor ‚Äì Export Vertices JSON</title>
<style>
/* ============  DESIGN TOKENS  ============ */
:root{
  --accent          : #2563eb;
  --accent-dark     : #1e40af;
  --surface         : #f9fafb;
  --border-neutral  : #d1d5db;
  --text-primary    : #111827;
  --shadow-lg       : 0 8px 22px rgba(0,0,0,.18);
  --iso-angle       : 12deg;        /* skew factor for isometric view   */
}

/* ============  APP LAYOUT  ============ */
html,body{margin:0;height:100%;font-family:system-ui,-apple-system,"Segoe UI",Helvetica,Arial,sans-serif;color:var(--text-primary);background:#fff}
#app{display:flex;height:100%}
#canvas{flex:1 1 auto;display:flex;justify-content:center;align-items:center;overflow:hidden;background:var(--surface)}
#sidebar{width:320px;max-width:100%;display:flex;flex-direction:column;background:var(--surface);border-left:2px solid var(--border-neutral);box-shadow:-3px 0 10px rgba(0,0,0,.07)}
#sidebar header{padding:1.1rem 1.3rem;background:var(--accent);color:#fff;box-shadow:var(--shadow-lg)}
#sidebar section{flex:1 1 auto;overflow-y:auto;padding:1.25rem 1.35rem}
#actions{padding:1rem 1.35rem;border-top:1px solid var(--border-neutral);display:flex;flex-wrap:wrap;gap:.8rem}

button{
  flex:1 1 calc(50% - .8rem);padding:.55rem .75rem;border:none;border-radius:.55rem;
  font-size:.94rem;font-weight:500;cursor:pointer;transition:background .18s,transform .18s;
  box-shadow:0 2px 5px rgba(0,0,0,.1)
}
button:hover{transform:translateY(-2px)}
button:active{transform:none}
button:disabled{background:#cbd5e1;color:#64748b;cursor:not-allowed;transform:none}
button:not(.secondary){background:var(--accent);color:#fff}
button.secondary{background:#9ca3af;color:#fff}
button.secondary:hover{background:#6b7280}

/* ============  ISOMETRIC WRAPPER  ============ */
/* add .iso to #viewport (or #map-content wrapper) to activate */
.iso{
  transform-origin:50% 0;
  transform:skewX(calc(var(--iso-angle)*-1)) translateY(-40px) scale(1.05);
  transition:transform .6s cubic-bezier(.25,.8,.25,1);
}

/* ============  ZONES (paths)  ============ */
svg path{
  stroke:transparent;filter:url(#isoZone);paint-order:stroke fill;
  transition:filter .25s ease,transform .25s ease;
}
svg path:hover{transform:translateY(-4px);filter:url(#isoZoneHover)}
svg path.active{transform:translateY(-6px);filter:url(#isoZoneActive)}

/* ============  VERTEX / HANDLE  ============ */
.handle{fill:#fff;stroke:var(--accent);stroke-width:2;cursor:move;filter:drop-shadow(0 1px 2px rgba(0,0,0,.25))}

/* ============  DRAW-PREVIEW LINE  ============ */
.draw-preview{fill:none;stroke:var(--accent);stroke-width:2;stroke-dasharray:6 4}

/* ============  DOTTED PATH DOTS  ============ */
.map-line-dot{
  r:7;fill:#fff;stroke:#2f2f2f;stroke-width:1.6;
  filter:url(#dotBevel);transition:fill .18s;
}
.map-line-dot.highlight{fill:#38bdf8}

/* ============  IMAGE TRIGGERS  ============ */
.img-trigger{
  transform-box:fill-box;
  transform:translate(-50%,-50%) scale(.12);opacity:0;
  transition:transform .4s ease,opacity .4s ease;
}
.img-trigger.visible{transition:transform 2s ease-in,opacity 2s ease-in}
.img-trigger.preview{opacity:.92;transform:translate(-50%,-50%) scale(1);outline:2px dashed #f59e0b}

/* ============  DISTANCE LABELS  ============ */
#distance-layer text{
  font-size:24px;font-weight:700;fill:#fff;paint-order:stroke;
  stroke:#111;stroke-width:.9px
}

.marker-icon{
  pointer-events:none;     /* üç∞  let the click fall through to the circle */
}

/* ============  FORM ELEMENTS  ============ */
input[type=checkbox]{accent-color:var(--accent);margin-right:.42em}
select{font-size:.95rem;padding:.15rem .35rem}
#sidebar hr{border:none;height:1px;background:var(--border-neutral);margin:.9rem 0 1.2rem}
</style>



</head>
<body>
<div id="app">
  <div id="canvas">
    <svg id="map-svg" viewBox="0 0 ${MAP_W} ${MAP_H}" width="90%" height="90%" preserveAspectRatio="xMidYMid meet">
      <rect id="frame" x="${MARGIN}" y="${MARGIN}" width="${MAP_W - 2*MARGIN}" height="${MAP_H - 2*MARGIN}" fill="#f9fafb" stroke="#9ca3af" stroke-width="4"/>
      <clipPath id="viewport-clip" clipPathUnits="userSpaceOnUse">
        <rect x="${MARGIN}" y="${MARGIN}" width="${MAP_W}" height="${MAP_H}"/>
      </clipPath>
      <g id="viewport" clip-path="url(#viewport-clip)">
        <g id="map-content">
          <path id="shop-a" data-label="Electronics Hub" fill="#d1d5db" d="M 80 80 L 300 80 L 300 400 L 80 400 Z"/>
          <path id="shop-b" data-label="Coffee Corner"   fill="#d1d5db" d="M 320 80 L 600 80 L 600 250 L 320 250 Z"/>
          <path id="shop-c" data-label="Book Store"      fill="#d1d5db" d="M 620 80 L 920 80 L 920 400 L 620 400 Z"/>
          <path id="shop-d" data-label="Fashion Outlet"  fill="#d1d5db" d="M 80 420 L 450 420 L 450 870 L 80 870 Z"/>
          <path id="shop-e" data-label="Toy World"        fill="#d1d5db" d="M 470 420 L 920 420 L 920 870 L 470 870 Z"/>
          <g id="handles-layer"></g>
          <polyline id="draw-preview" class="draw-preview" visibility="hidden"/>
          <g id="distance-layer"></g>
          <g id="markers-layer"></g>
          <g id="lines-layer"></g>
          <line id="line-preview" stroke="#2563eb" stroke-width="10" stroke-dasharray="6 4" fill="none" visibility="hidden" />
          </g>
        </g>
    </svg>
  </div>

  <aside id="sidebar">
    <header>
      <h2 id="zone-title">Select or Draw</h2>
      <p id="zone-meta" style="margin:0;font-size:.9rem;opacity:.85">
        Left‚Äëclick to add vertices, <strong>right‚Äëclick to finish</strong>.
      </p>
    </header>

    <section id="zone-info">
      <div style="margin-top:.5rem;">
        <label>
          <input type="checkbox" id="toggle-lines" checked>
          Show drawn lines
        </label>
      </div>
      <div id="status-msg"><em>Select a zone to view details.</em></div>
      <hr/>
      <h4 style="margin-top:.5rem">Find path between markers</h4>
      <label>From:
        <select id="from-marker"></select>
      </label><br/>
      <label style="margin-top:.25rem">To:
        <select id="to-marker"></select>
      </label><br/>
      <button id="find-path-btn" class="secondary" style="margin-top:.5rem">Highlight path</button>
      <button id="clear-path-btn" class="secondary" style="margin-top:.5rem">Clear</button>
      
      <div id="color-picker" style="margin-top:1rem; display:none;">
        <label for="fill-color" style="font-size:0.9rem; font-weight:500;">Fill color:</label><br/>
        <input type="color" id="fill-color" value="#d1d5db" style="margin-top:0.25rem; width: 40px; height:2rem; border:none;"/>
      </div>
      <div style="margin-top: 1rem;">
        <label><input type="checkbox" id="toggle-distances"> Show edge distances</label>
      </div>
    </section>

    <div id="actions">
      <button id="add-btn">Add Zone</button>
      <button id="delete-btn" class="secondary" disabled>Delete Zone</button>
      <button id="export-btn" class="secondary">Export¬†JSON</button>
      <button id="import-btn" class="secondary">Import JSON</button>
      <button id="line-btn" class="secondary">Add Line</button>
      <button id="delete-line-btn" class="secondary">Delete Line</button>
      <input type="file" id="import-file" accept="application/json" style="display:none"/>
      <button id="marker-btn" class="secondary">Add Marker</button><br/>
      <button id="delete-marker-btn" class="secondary">Delete Marker</button>
      <button id="cancel-btn" class="secondary" disabled>Cancel</button>
      <button id="export-paths-btn" class="secondary">Export Paths</button>
      <button id="textbox-btn" class="secondary">Add Text</button>
      <button id="add-img-btn" class="secondary">Add Image Trigger</button>
      <button id="toggle-invisible"   class="secondary">üëÅÔ∏è Show Hidden Images</button>
      <button id="delete-img-btn"   class="secondary">Delete Image Trigger</button>
      <input  id="img-file"    type="file" accept="image/*" style="display:none">
      <label style="display:block;margin-top:.25rem">
        Icon:
        <select id="marker-icon"></select>
      </label>
    </div>
  </aside>
</div>

<script>
const svg = document.getElementById('map-svg');
const handlesLayer = document.getElementById('handles-layer');
const previewLine  = document.getElementById('draw-preview');
const addBtn = document.getElementById('add-btn');
const cancelBtn = document.getElementById('cancel-btn');
const exportBtn = document.getElementById('export-btn');
const zoneInfo  = document.getElementById('zone-info');
const titleBox  = document.getElementById('zone-title');
const metaBox   = document.getElementById('zone-meta');
const deleteBtn = document.getElementById('delete-btn');
const distanceLayer = document.getElementById('distance-layer');
const lineBtn = document.getElementById('line-btn');
const mapContent = document.getElementById("map-content");


const clip = svg.querySelector("#viewport-clip rect");
const frame = svg.querySelector("#frame");


const MAP_W   = 3000;    // <-- change this one number to grow / shrink the map
const MAP_H   = 2000;    //                 ‚Ä≥
const MARGIN  = 50;      // frame thickness on every side


let zoom = 1;           // current zoom factor
let panX = 0;           // accumulated pan offset
let panY = 0;
let panning = false;    // middle-button drag flag
let lastSVG = { x: 0, y: 0 };   // last mouse position in SVG coords

// centre of the 1400 √ó 900 viewport rectangle
const cx = MARGIN + (MAP_W - 2*MARGIN)/2;
const cy = MARGIN + (MAP_H - 2*MARGIN)/2;

const MARKER_SIZE   = 120;   // icon bitmap in px
const MARKER_RADIUS = 12;   // the orange snap
const IMAGE_SIZE = 120
//
let zoneCounter = 1 + svg.querySelectorAll('path').length;
let currentZone = null;
let dragMode=null; // move | vertex | draw | null
let dragButton = null;
let activeHandleIdx=-1; let startPt=null; let originalD=''; let drawVerts=[];
let lineMode = false;
let lineStart = null;
const linePreview = document.getElementById('line-preview');
let currentLine = null;
let currentHandle = null;
let lineCounter = 0;          // running id for new lines
let markerMode = false;
const statusMsg = document.getElementById('status-msg');
let deleteLineMode = false;
let markerDeleteMode = false;
let textMode = false;
let imgTriggers = [];          // [{x,y,el,active}, ‚Ä¶]
let showInvisible = false;
let imgAddMode  = false;       // stores {url} while user chooses spot
const ICONS = [
  { name: 'Lift',      url: 'icons/lift.png'      },
  { name: 'Restroom',  url: 'icons/restroom.png'  },
  { name: 'Info',      url: 'icons/info.png'      },
  { name: 'Room',      url: 'icons/room.png'      },
  { name: 'Stairs',      url: 'icons/stairs.png'      },
  // ‚Ä¶add as many as you like
];
buildIconPicker();


//constants
const CLOSE_THRESHOLD = 20; // pixels
const PIXELS_PER_METER = 50;
let pathTimer = null;      // interval id for the animation
const STEP_MS = 120;       // <-- one dot every 120 ms  (tweak freely)

/********* Utility *********/
function refreshMarkerDropdowns() {
  const opts = [...document.querySelectorAll('#markers-layer circle')]
    .map(c => `<option value="${c.dataset.label}">${c.dataset.label}</option>`)
    .join('');

  document.getElementById('from-marker').innerHTML = '<option value="">--</option>' + opts;
  document.getElementById('to-marker').innerHTML   = '<option value="">--</option>' + opts;
}
function svgPoint(evt){
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX;
  pt.y = evt.clientY;
  // use the current matrix of <g id="map-content">
  return pt.matrixTransform(mapContent.getScreenCTM().inverse());
}
function translatePath(el,dx,dy){const pieces=el.getAttribute('d').match(/[a-zA-Z][^a-zA-Z]*/g);const rebuilt=pieces.map(seg=>{const type=seg.trim()[0];const nums=seg.slice(1).trim();if(!nums)return seg;const vals=nums.split(/[ ,]+/).filter(Boolean).map(Number);if(type==='M'||type==='L'){for(let i=0;i<vals.length;i+=2){vals[i]+=dx;vals[i+1]+=dy;}}else if(type==='H'){vals.forEach((v,i)=>vals[i]+=dx);}else if(type==='V'){vals.forEach((v,i)=>vals[i]+=dy);}return type+' '+vals.join(' ')});el.setAttribute('d',rebuilt.join(' '));}
function pathToVertices(d){const nums=d.replace(/[MLZmlz]/g,'').trim().split(/[ ,]+/).filter(Boolean).map(Number);const verts=[];for(let i=0;i<nums.length;i+=2) verts.push([nums[i],nums[i+1]]);return verts;}
function verticesToPath(verts){return verts.map((v,i)=>(i?'L':'M')+' '+v[0]+' '+v[1]).join(' ')+' Z';}
function clearHandles(){handlesLayer.innerHTML='';}
function renderHandles(el){clearHandles();pathToVertices(el.getAttribute('d')).forEach((v,i)=>{const c=document.createElementNS('http://www.w3.org/2000/svg','circle');c.setAttribute('cx',v[0]);c.setAttribute('cy',v[1]);c.setAttribute('r',10);c.classList.add('handle');c.dataset.idx=i;handlesLayer.appendChild(c);c.addEventListener('pointerdown',startVertexDrag);});}
function deleteZone () {
  if (!currentZone) return;                         // nothing selected

  /* 1Ô∏è‚É£  remove the ‚Äúwall‚Äù that belongs to this zone */
  const wall = document.querySelector(
      `.zone-wall[data-for="${currentZone.id}"]`);
  if (wall) wall.remove();

  /* 2Ô∏è‚É£  remove the top polygon itself */
  currentZone.remove();
  currentZone = null;

  /* 3Ô∏è‚É£  UI clean-up */
  clearHandles();                                   // throw away blue handles
  distanceLayer.innerHTML = '';                     // hide edge lengths
  deleteBtn.disabled = true;                        // grey-out button
  titleBox.textContent = 'Select or Draw';
  metaBox.textContent  = '';
  setStatus('<em>Select a zone to view details.</em>');
}
function rgbToHex(rgb) {
  const result = rgb.match(/\d+/g);
  if (!result || result.length < 3) return '#d1d5db'; // fallback
  return (
    '#' +
    result.slice(0, 3)
      .map(x => parseInt(x).toString(16).padStart(2, '0'))
      .join('')
  );
}
function renderAllDistances() {
  distanceLayer.innerHTML = ''; // Clear all existing

  svg.querySelectorAll('path').forEach(zone => {
    const verts = pathToVertices(zone.getAttribute('d'));

    for (let i = 0; i < verts.length; i++) {
      const a = verts[i];
      const b = verts[(i + 1) % verts.length];
      const midX = (a[0] + b[0]) / 2;
      const midY = (a[1] + b[1]) / 2;

      const pixelDist = Math.hypot(b[0] - a[0], b[1] - a[1]);
      const distInMeters = (pixelDist / PIXELS_PER_METER).toFixed(2);

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', midX);
      text.setAttribute('y', midY);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('font-size', '24px');
      text.setAttribute('font-weight', 'bold');
      text.setAttribute('fill', '#111');             // Main text color
      text.setAttribute('stroke', 'white');          // Outline
      text.setAttribute('stroke-width', '1');        // Outline thickness
      text.textContent = `${distInMeters} m`;
      distanceLayer.appendChild(text);
    }
  });
}
function highlightPath(labels) {
  clearHighlight();
  if (!labels || labels.length < 2) return;

    // reset all triggers
  imgTriggers.forEach(t=>{
    t.active = false;
    t.el.style.transform = 'scale(0.1)';
    t.el.style.opacity   = 0;
  });

  const sequence = [];
  const allLines = [...document.querySelectorAll('#lines-layer line')];

  for (let i = 0; i < labels.length - 1; i++) {
    const F = labels[i], T = labels[i + 1];

    const match = allLines.find(l =>
      l._markers &&
      ((l._markers[0] === F && l._markers[1] === T) ||
       (l._markers[0] === T && l._markers[1] === F))
    );

    if (match) {
      const orderedDots = (match._markers[0] === F)
        ? match._dots
        : [...match._dots].reverse();
      sequence.push(...orderedDots);
    }
  }

  if (!sequence.length) return;

  sequence.forEach(d => d.style.display = 'inline');

  let idx = 0;
  pathTimer = setInterval(() => {
    if (idx >= sequence.length) {
      clearInterval(pathTimer);
      pathTimer = null;
      return;
    }
    const dot = sequence[idx];
    dot.style.fill = '#38bdf8';
    updateImageTriggers(+dot.getAttribute('cx'), +dot.getAttribute('cy'));
    idx++;
  }, STEP_MS);
}
function clearHighlight() {
  if (pathTimer) { clearInterval(pathTimer); pathTimer = null; }
  document.querySelectorAll('.map-line-dot').forEach(d =>
    d.style.fill = '#fff');

  imgTriggers.forEach(t => {
    t.active = false;
    t.el.style.transform = 'scale(0.1)';
    t.el.style.opacity   = 0;
  });
  updateLineVisibility();
}
function setStatus(html) {
  statusMsg.innerHTML = html;
}
function updateLineVisibility() {
  const show = document.getElementById('toggle-lines').checked;
  document.querySelectorAll('.map-line-dot').forEach(d => {
    // keep whatever colour the dot already has, just toggle display
    d.style.display = show ? 'inline' : 'none';
  });
}
function snapToSegment(px, py, ax, ay, bx, by) {
  const vx = bx - ax,  vy = by - ay;
  const wx = px - ax,  wy = py - ay;

  const segLen2 = vx*vx + vy*vy;
  if (!segLen2) return null;                 // A and B are the same point

  // parameter t of the projection, clamped to [0,1]
  let t = (vx*wx + vy*wy) / segLen2;
  if (t < 0) t = 0;
  else if (t > 1) t = 1;

  return { x: ax + t*vx, y: ay + t*vy };
}
function extrudeZones(depth = 12, wallColor = 'rgba(0,0,0,.18)') {
  // remove the previous walls
  document.querySelectorAll('.zone-wall').forEach(e => e.remove());

  [...document.querySelectorAll('#map-content path')].forEach(top => {
    /* ‚îÄ‚îÄ build ONE new <path> that encloses   */
    /*    the top polygon + the shifted bottom */
    const topPts = pathToVertices(top.getAttribute('d'));
    const botPts = topPts.map(([x, y]) => [x + depth, y + depth]).reverse();

    const wall = document.createElementNS(svg.namespaceURI, 'path');
    wall.classList.add('zone-wall');
    wall.setAttribute('fill', wallColor);
    wall.setAttribute('pointer-events', 'none');          // never selectable
    wall.setAttribute('data-for', top.id);                // ‚Üê needed by refresh
    wall.setAttribute(
      'd',
      [...topPts, ...botPts]
        .map((p, i) => (i ? 'L' : 'M') + p[0] + ' ' + p[1])
        .join(' ') + ' Z'
    );

    /* IMPORTANT: NO extra translate( ‚Ä¶ ) here ‚Äî                      */
    /* the vertices are already shifted, adding a   transform doubles */
    /* the offset and makes the wall ‚Äúfloat‚Äù.                         */

    top.parentNode.insertBefore(wall, top);   // draw under the roof
  });
}

function refreshWallFor(zone, depth = 12) {
  const wall = document.querySelector(`.zone-wall[data-for="${zone.id}"]`);
  if (!wall) return;

  const topPts = pathToVertices(zone.getAttribute('d'));
  const botPts = topPts.map(([x, y]) => [x + depth, y + depth]).reverse();

  wall.setAttribute(
    'd',
    [...topPts, ...botPts]
      .map((p, i) => (i ? 'L' : 'M') + p[0] + ' ' + p[1])
      .join(' ') + ' Z'
  );
}


extrudeZones(12);
/********* Selection *********/
function selectZone(zone) {
  svg.querySelectorAll('path').forEach(z => z.classList.remove('active'));
  zone.classList.add('active');
  currentZone = zone;

  renderHandles(zone);

  titleBox.textContent = zone.dataset.label || zone.id;
  metaBox.textContent = `ID: ${zone.id}`;
  zoneInfo.querySelector('em')?.remove();

  // Show and update color picker
  const picker = document.getElementById('color-picker');
  picker.style.display = 'block';

  const computedFill = window.getComputedStyle(zone).fill;
  document.getElementById('fill-color').value = rgbToHex(computedFill);

  const show = document.getElementById('toggle-distances').checked;
  if (show) renderAllDistances();
  else distanceLayer.innerHTML = '';

  deleteBtn.disabled = false;
}
function buildIconPicker() {
  const sel = document.getElementById('marker-icon');
  sel.innerHTML = ICONS.map(i =>
    `<option value="${i.url}">${i.name}</option>`).join('');
}

/********* Drag existing *********/
function startZoneMove(evt) {
  if (dragMode || evt.button !== 1) return; // middle click only
  evt.stopPropagation();
  dragMode = 'move';
  dragButton = evt.button;
  selectZone(evt.currentTarget);
  startPt = mapPoint(evt);
  evt.currentTarget.setPointerCapture(evt.pointerId);
}
function startVertexDrag(evt) {
  if (evt.button !== 0) return; // left click only
  evt.stopPropagation();
  dragMode = 'vertex';
  dragButton = evt.button;
  activeHandleIdx = parseInt(evt.currentTarget.dataset.idx);
  startPt = mapPoint(evt);
  originalD = currentZone.getAttribute('d');
  evt.currentTarget.setPointerCapture(evt.pointerId);
}
function onPointerMove(evt) {

  if (panning) return;
  const p = mapPoint(evt);

  if (dragMode === 'move') {
    const dx = p.x - startPt.x;
    const dy = p.y - startPt.y;
    translatePath(currentZone, dx, dy);
    startPt = p;
    renderHandles(currentZone);

    if (document.getElementById('toggle-distances').checked) {
      renderAllDistances(); // Recalculate and redraw all distances
    } else {
      distanceLayer.innerHTML = '';
    }
    refreshWallFor(currentZone);
  } 

  if (dragMode === 'line' && currentLine && currentLine._dots) {
    const dx = p.x - startPt.x;
    const dy = p.y - startPt.y;

    translateLine(currentLine, dx, dy);
    startPt = p;

    // update dot positions
    const x1 = parseFloat(currentLine.getAttribute('x1'));
    const y1 = parseFloat(currentLine.getAttribute('y1'));
    const x2 = parseFloat(currentLine.getAttribute('x2'));
    const y2 = parseFloat(currentLine.getAttribute('y2'));

    const dxL = x2 - x1;
    const dyL = y2 - y1;
    const dist = Math.hypot(dxL, dyL);
    const steps = currentLine._dots.length - 1;
    const unitX = dxL / dist;
    const unitY = dyL / dist;
    const spacing = dist / steps;

    currentLine._dots.forEach((dot, i) => {
      dot.setAttribute('cx', x1 + unitX * i * spacing);
      dot.setAttribute('cy', y1 + unitY * i * spacing);
    });
  }


  else if (dragMode === 'vertex') {
    const dx = p.x - startPt.x;
    const dy = p.y - startPt.y;
    const verts = pathToVertices(originalD);

    // Move the active vertex
    verts[activeHandleIdx][0] += dx;
    verts[activeHandleIdx][1] += dy;

    const moved = verts[activeHandleIdx];
    const others = getAllVerticesExceptCurrent(currentZone);
    for (let v of others) {
      const dist = Math.hypot(moved[0] - v[0], moved[1] - v[1]);
      if (dist < CLOSE_THRESHOLD) {
        moved[0] = v[0];
        moved[1] = v[1];
        break;
      }
    }
    // If it's the last vertex, check if close to the first and snap
    if (activeHandleIdx === verts.length - 1) {
      const first = verts[0];
      const last = verts[verts.length - 1];
      const dist = Math.hypot(last[0] - first[0], last[1] - first[1]);

      if (dist < CLOSE_THRESHOLD) {
        verts[verts.length - 1][0] = first[0];
        verts[verts.length - 1][1] = first[1];
      }
    }

    currentZone.setAttribute('d', verticesToPath(verts));
    renderHandles(currentZone);
    refreshWallFor(currentZone);
    if (document.getElementById('toggle-distances').checked) {
      renderAllDistances();
    } else {
      distanceLayer.innerHTML = '';
    }
  } 
  
  else if (dragMode === 'draw' && drawVerts.length) {
    const preview = [...drawVerts, [p.x, p.y]];
    previewLine.setAttribute('points', preview.map(v => v.join(',')).join(' '));
  }

  else if (dragMode === 'line-handle' && currentHandle && currentLine) {

   const raw  = svgPoint(evt);
   const snap = getNearestSnapPoint(raw);

   currentHandle.setAttribute('cx', snap.x);
   currentHandle.setAttribute('cy', snap.y);
   currentLine  .setAttribute(currentHandle._attrX, snap.x);
   currentLine  .setAttribute(currentHandle._attrY, snap.y);

   // üü¢ now recalc dots with the final snapped endpoints
   if (currentLine._dots) {
     const x1 = +currentLine.getAttribute('x1'),
           y1 = +currentLine.getAttribute('y1'),
           x2 = +currentLine.getAttribute('x2'),
           y2 = +currentLine.getAttribute('y2');
     const dx = x2 - x1,  dy = y2 - y1,
           dist = Math.hypot(dx, dy),
           steps = currentLine._dots.length - 1,
           ux = dx / dist, uy = dy / dist,
           spacing = dist / steps;
     currentLine._dots.forEach((d, i) => {
       d.setAttribute('cx', x1 + ux * i * spacing);
       d.setAttribute('cy', y1 + uy * i * spacing);
     });
   }
  }

  else if (dragMode === 'textbox' && currentHandle) {
    const dx = p.x - startPt.x;
    const dy = p.y - startPt.y;

    // update background rect
    const r = currentHandle.querySelector('rect');
    r.setAttribute('x', +r.getAttribute('x') + dx);
    r.setAttribute('y', +r.getAttribute('y') + dy);

    // update the text
    const t = currentHandle.querySelector('text');
    t.setAttribute('x', +t.getAttribute('x') + dx);
    t.setAttribute('y', +t.getAttribute('y') + dy);

    startPt = p;
  }

  if (lineMode && lineStart) {
    const pt = svgPoint(evt);
    const snapPt = getNearestSnapPoint(pt);
    linePreview.setAttribute('x1', lineStart.x);
    linePreview.setAttribute('y1', lineStart.y);
    linePreview.setAttribute('x2', snapPt.x);
    linePreview.setAttribute('y2', snapPt.y);
    linePreview.setAttribute('visibility', 'visible');
  }
}
function endDrag(evt) {
  if (
    (dragMode === 'move'   && dragButton === 1) ||   // zone
    (dragMode === 'vertex' && dragButton === 0) ||   // vertex
    (dragMode === 'line'   && dragButton === 1) ||     // line  ‚Üê add this clause
    (dragMode === 'line-handle' && dragButton === 0) ||
    (dragMode === 'textbox'     && dragButton === 1)
  ) {
    dragMode   = null;
    dragButton = null;
    currentLine = null;
    currentHandle = null;
  }

  if (evt.pointerId) {
    evt.currentTarget.releasePointerCapture(evt.pointerId);
  }
}
function getAllVerticesExceptCurrent(zoneEl) {
  const otherPaths = [...svg.querySelectorAll('path')].filter(p => p !== zoneEl);
  let points = [];
  otherPaths.forEach(path => {
    pathToVertices(path.getAttribute('d')).forEach(v => points.push(v));
  });
  return points;
}
function translateLine(el, dx, dy) {
  ['x1','x2'].forEach(a=>el.setAttribute(a, +el.getAttribute(a)+dx));
  ['y1','y2'].forEach(a=>el.setAttribute(a, +el.getAttribute(a)+dy));
}
function updateImageTriggers(dotX, dotY){
  const HIT_RADIUS      = 12;   // keep as-is (or enlarge if you like)
  const HOLD_MS         = 4000; // ‚Üê how long the image must stay visible

  imgTriggers.forEach(t => {
    const near = Math.hypot(t.x - dotX, t.y - dotY) < HIT_RADIUS;

    /*‚îÄ‚îÄ‚îÄ‚îÄ dot ENTERS trigger ‚îÄ‚îÄ‚îÄ‚îÄ*/
    if (near && !t.active){
      t.active = true;
      clearTimeout(t.hideTimer);        // cancel a pending hide (if any)
      t.el.style.opacity   = 1;
      t.el.style.transform = 'translate(-50%,-50%) scale(1.6)';
    }

    /*‚îÄ‚îÄ‚îÄ‚îÄ dot LEAVES trigger ‚îÄ‚îÄ‚îÄ‚îÄ*/
    else if (!near && t.active){
      t.active = false;

      /* wait HOLD_MS before hiding ‚Äì unless dot comes back in the meantime */
      t.hideTimer = setTimeout(()=>{
        if (!t.active){                // dot hasn‚Äôt re-entered
          t.el.style.transform = 'scale(0.1)';
          t.el.style.opacity   = 0;
        }
      }, HOLD_MS);
    }
  });
}



/********* Draw mode *********/
function beginDraw(){
  dragMode='draw';drawVerts=[];
  previewLine.setAttribute('visibility','visible');
  previewLine.setAttribute('points','');addBtn.disabled=true;
  cancelBtn.disabled=false;
  setStatus('Left-click to add vertices, <strong>right-click to finish</strong>.');
}
function cancelDraw(){
  dragMode=null;
  deleteBtn.disabled = true;
  drawVerts=[];previewLine.setAttribute('visibility','hidden');
  addBtn.disabled=false;cancelBtn.disabled=true;
  setStatus('<em>Select a zone to view details.</em>');
} 
function finishDraw(){
  if(drawVerts.length<3){
    cancelDraw();
    return;
  }
  
  const id=`zone-${zoneCounter++}`;
  const p=document.createElementNS('http://www.w3.org/2000/svg','path');
  p.setAttribute('id',id);
  p.setAttribute('data-label',id);
  p.setAttribute('fill','#d1d5db');
  p.setAttribute('d',verticesToPath(drawVerts));
  mapContent.insertBefore(p, handlesLayer);
  p.addEventListener('click',()=>selectZone(p));
  p.addEventListener('pointerdown',startZoneMove);
  cancelDraw();
  selectZone(p);
} 
function onSvgLeftClick(evt){if(dragMode!=='draw'||evt.button!==0)return;const p=svgPoint(evt);drawVerts.push([p.x,p.y]);previewLine.setAttribute('points',drawVerts.map(v=>v.join(',')).join(' '));} 
function onSvgRightClick(evt){if(dragMode==='draw'){evt.preventDefault();finishDraw();}} 
function drawLine(from, to) {
  const layer = document.getElementById('lines-layer');
  const spacing = 20; // distance between dots
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const dist = Math.hypot(dx, dy);
  const steps = Math.floor(dist / spacing);
  const unitX = dx / dist;
  const unitY = dy / dist;

  const lineId = `line-${++lineCounter}`;
  const dots = [];

  for (let i = 0; i <= steps; i++) {
    const x = from.x + unitX * i * spacing;
    const y = from.y + unitY * i * spacing;

    const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    dot.setAttribute('cx', x);
    dot.setAttribute('cy', y);
    dot.setAttribute('r', 6);
    dot.setAttribute('fill', '#fff');
    dot.setAttribute('stroke', '#000');
    dot.setAttribute('stroke-width', 2);
    dot.classList.add('map-line-dot');
    dot.dataset.parentLine = lineId;

    dot.addEventListener('click', e => {
      if (!deleteLineMode) return;
      e.stopPropagation();                 // don‚Äôt let the click reach anything else

      ghostLine.remove();                  // remove the hidden <line>
      dots.forEach(d => d.remove());       // remove all dots
      handle1.remove();                    // remove endpoint handles
      handle2.remove();

      deleteLineMode = false;              // reset UI
      document.getElementById('delete-line-btn').textContent = 'Delete Line';
    });


    // Optional: delete entire line on right-click
    dot.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      dots.forEach(d => d.remove());
      handle1.remove();
      handle2.remove();
    });

    dots.push(dot);
    layer.appendChild(dot);
  }

  // Add invisible <line> for dragging and snapping logic
  const ghostLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  ghostLine.setAttribute('id', lineId);
  ghostLine.setAttribute('x1', from.x);
  ghostLine.setAttribute('y1', from.y);
  ghostLine.setAttribute('x2', to.x);
  ghostLine.setAttribute('y2', to.y);
  ghostLine.setAttribute('stroke', 'transparent');   // clickable hit-box
  ghostLine.setAttribute('stroke-width', 20);        // wide enough to grab
  ghostLine.setAttribute('pointer-events', 'stroke');
  ghostLine._dots = dots; // store reference for manipulation

  ghostLine.addEventListener('click', (e) => {
    if (!deleteLineMode) return;

    e.stopPropagation();

    ghostLine.remove();
    dots.forEach(dot => dot.remove());

    // Remove handles if tagged
    [...handlesLayer.querySelectorAll('circle')].forEach(h => {
      if (h._lineRef === ghostLine) h.remove();
    });

    deleteLineMode = false;
    document.getElementById('delete-line-btn').textContent = 'Delete Line';
  });
  layer.appendChild(ghostLine);

  ghostLine.addEventListener('pointerdown', (e) => {
    if (e.button !== 1) return;
    e.stopPropagation();
    dragMode = 'line';
    dragButton = 1;
    currentLine = ghostLine;
    startPt = mapPoint(e);

    ghostLine._orig = {
      x1: parseFloat(ghostLine.getAttribute('x1')),
      y1: parseFloat(ghostLine.getAttribute('y1')),
      x2: parseFloat(ghostLine.getAttribute('x2')),
      y2: parseFloat(ghostLine.getAttribute('y2')),
    };

    ghostLine.setPointerCapture(e.pointerId);
  });

  // Create endpoint handles
  const handle1 = createLineHandle(from.x, from.y, ghostLine, 'x1', 'y1');
  const handle2 = createLineHandle(to.x, to.y, ghostLine, 'x2', 'y2');
  handle1._lineRef = ghostLine;
  handle2._lineRef = ghostLine;

  handlesLayer.appendChild(handle1);
  handlesLayer.appendChild(handle2);
  updateLineVisibility();
}
function getNearestSnapPoint(pt) {
  let best = null;
  let bestDist = Infinity;

  /* ‚è© 1. markers ‚Äì if we‚Äôre already over one, snap & bail out */
  const MARKER_LOCK = 18;                   /* px ‚Äì tweak if you like  */
  for (const c of document.querySelectorAll('#markers-layer circle')){
    const x = +c.getAttribute('cx'), y = +c.getAttribute('cy');
    if (Math.hypot(x - pt.x, y - pt.y) < MARKER_LOCK){
      return { x, y };                      /* ‚Üê nothing else matters */
    }
  }

  /* 2.  markers ‚Äì still highest priority if none inside MARKER_LOCK */
  document.querySelectorAll('#markers-layer circle').forEach(c => {
    const x = +c.getAttribute('cx'), y = +c.getAttribute('cy');
    const d = Math.hypot(x - pt.x, y - pt.y);
    if (d < bestDist){ bestDist = d; best = { x, y }; }
  });

  /* 1Ô∏è‚É£  vertices of all polygons  */
  svg.querySelectorAll('path').forEach(p => {
    pathToVertices(p.getAttribute('d')).forEach(([x,y]) => {
      const d = Math.hypot(x - pt.x, y - pt.y);
      if (d < bestDist) { bestDist = d; best = {x,y}; }
    });
  });

  /* 2Ô∏è‚É£  every edge of every polygon  */
  svg.querySelectorAll('path').forEach(p => {
    const verts = pathToVertices(p.getAttribute('d'));
    for (let i = 0; i < verts.length; i++) {
      const [ax,ay] = verts[i];
      const [bx,by] = verts[(i+1)%verts.length];
      const proj = snapToSegment(pt.x, pt.y, ax, ay, bx, by);
      const d    = Math.hypot(proj.x - pt.x, proj.y - pt.y);
      if (d < bestDist) { bestDist = d; best = proj; }
    }
  });

  /* 3Ô∏è‚É£  endpoints *and* whole length of drawn lines  */
  document.querySelectorAll('#lines-layer line').forEach(l => {
    if (l === currentLine) return;
    const x1 = +l.getAttribute('x1'), y1 = +l.getAttribute('y1');
    const x2 = +l.getAttribute('x2'), y2 = +l.getAttribute('y2');

    // endpoints
    [ [x1,y1], [x2,y2] ].forEach(([x,y]) => {
      const d = Math.hypot(x - pt.x, y - pt.y);
      if (d < bestDist) { bestDist = d; best = {x,y}; }
    });
  });

  return bestDist < CLOSE_THRESHOLD ? best : pt;
}
function buildMarkerGraph() {
  const G = {};                                // label ‚Üí {x, y, neighbors}

  /* ‚Äî‚Äî real markers (visible circles) ‚Äî‚Äî */
  document.querySelectorAll('#markers-layer circle').forEach(c => {
    const lbl = c.dataset.label;
    if (!lbl) return;                          // skip auto circles, if any
    G[lbl] = {
      x: +c.getAttribute('cx'),
      y: +c.getAttribute('cy'),
      neighbors: new Set()
    };
  });

  /* ‚Äî‚Äî every ghost line creates / links two nodes ‚Äî‚Äî */
  document.querySelectorAll('#lines-layer line').forEach(l => {
    const x1 = +l.getAttribute('x1'), y1 = +l.getAttribute('y1');
    const x2 = +l.getAttribute('x2'), y2 = +l.getAttribute('y2');

    const n1 = getOrMakeNodeLabel(x1, y1, G);
    const n2 = getOrMakeNodeLabel(x2, y2, G);

    if (n1 === n2) return;                     // zero‚Äëlength after snap
    G[n1].neighbors.add(n2);
    G[n2].neighbors.add(n1);

    // store for highlightPath()
    l._markers = [n1, n2];
  });

  return G;
}

function shortestPath(startLbl, endLbl) {
  const G = buildMarkerGraph();
  if (!G[startLbl] || !G[endLbl]) return null;

  const q = [startLbl];
  const prev = { [startLbl]: null };

  while (q.length) {
    const v = q.shift();
    if (v === endLbl) break;
    G[v].neighbors.forEach(n => {
      if (!(n in prev)) {
        prev[n] = v;
        q.push(n);
      }
    });
  }

  if (!(endLbl in prev)) return null; // unreachable

  // rebuild path labels
  const path = [];
  let cur = endLbl;
  while (cur) {
    path.push(cur);
    cur = prev[cur];
  }
  return path.reverse();
}
function createLineHandle(x, y, line, attrX, attrY) {
  const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  handle.setAttribute('cx', x);
  handle.setAttribute('cy', y);
  handle.setAttribute('r', 8);
  handle.setAttribute('fill', '#fff');
  handle.setAttribute('stroke', '#2563eb');
  handle.setAttribute('stroke-width', 2);
  handle.style.cursor = 'move';

  handle.addEventListener('pointerdown', (e) => {
    if (e.button !== 0) return; // Left click only
    e.stopPropagation();
    dragMode = 'line-handle';
    dragButton = 0;
    currentHandle = handle;
    currentLine = line;
    handle._attrX = attrX;
    handle._attrY = attrY;
    startPt = mapPoint(e);
    handle.setPointerCapture(e.pointerId);
  });

  return handle;
}
function drawDottedLine(from, to) {
  const layer = document.getElementById('lines-layer');
  const spacing = 20; // pixels between dots

  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const dist = Math.hypot(dx, dy);
  const steps = Math.floor(dist / spacing);
  const unitX = dx / dist;
  const unitY = dy / dist;

  for (let i = 0; i <= steps; i++) {
    const x = from.x + unitX * i * spacing;
    const y = from.y + unitY * i * spacing;

    const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    dot.setAttribute('cx', x);
    dot.setAttribute('cy', y);
    dot.setAttribute('r', 6); // adjust size here
    dot.setAttribute('fill', '#fff');
    dot.setAttribute('stroke', '#000');
    dot.setAttribute('stroke-width', 2);
    layer.appendChild(dot);
  }
}
function mapPoint(evt){
   const pt = svg.createSVGPoint();
  pt.x = evt.clientX;            //  << load screen coords
  pt.y = evt.clientY;
   return pt.matrixTransform( mapContent.getScreenCTM().inverse() );
}
function applyTransform() {
  const mapContent = document.querySelector("#map-content");
  mapContent.setAttribute(
    "transform",
    // ‚ë† pan (screen-space)           ‚ë° scale about centre point
    `translate(${panX},${panY}) translate(${cx},${cy}) scale(${zoom}) translate(${-cx},${-cy})`
  );
}


function exportJSON () {
  /* ---------- zones ---------- */
  const zones = [...svg.querySelectorAll('path')].map(p => {
    const vertices = pathToVertices(p.getAttribute('d'));
    const edge_lengths_m = vertices.map((v, i) => {
      const b = vertices[(i + 1) % vertices.length];
      return +(Math.hypot(b[0] - v[0], b[1] - v[1]) / PIXELS_PER_METER).toFixed(2);
    });
    return {
      id    : p.id,
      label : p.dataset.label || '',
      color : p.style.fill || getComputedStyle(p).fill,
      vertices,
      edge_lengths_m
    };
  });

  /* ---------- lines ---------- */
  const lines = [...document.querySelectorAll('#lines-layer line')].map(l => ({
    id          : l.id,
    x1          : +l.getAttribute('x1'),
    y1          : +l.getAttribute('y1'),
    x2          : +l.getAttribute('x2'),
    y2          : +l.getAttribute('y2'),
    stroke      : l.getAttribute('stroke')       || '#000',
    strokeWidth : +(l.getAttribute('stroke-width') || 3),
    dots        : (l._dots || []).map(d => ({
      cx : +d.getAttribute('cx'),
      cy : +d.getAttribute('cy')
    }))
  }));

  /* ---------- markers (visible only) ---------- */
  const markers = [...document.querySelectorAll('#markers-layer circle.map-marker')]
    .map(c => ({
      cx     : +c.getAttribute('cx'),
      cy     : +c.getAttribute('cy'),
      label  : c.dataset.label || '',
      radius : +c.getAttribute('r') || 8,
      icon   : c.dataset.icon  || ''
    }));

  /* ---------- text boxes ---------- */
  const textboxes = [...document.querySelectorAll('.map-textbox')].map(g => {
    const t = g.querySelector('text');
    return { x: +t.getAttribute('x'), y: +t.getAttribute('y'), text: t.textContent };
  });

  /* ---------- image triggers ---------- */
  const images = imgTriggers.map(t => ({
    x      : t.x,
    y      : t.y,
    url    : t.el.getAttribute('href') ||
             t.el.getAttributeNS('http://www.w3.org/1999/xlink', 'href'),
    width  : +t.el.getAttribute('width'),
    height : +t.el.getAttribute('height')
  }));

  /* ---------- editor settings ---------- */
  const settings = {
    showLines : document.getElementById('toggle-lines').checked
  };

  /* ---------- write file ---------- */
  const data = { zones, lines, markers, textboxes, images, settings };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type : 'application/json' });
  const a    = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'map.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

async function importJSON(file) {
  if (!file) return;

  /* ---------- read file ---------- */
  const text = await file.text();
  let data;
  try { data = JSON.parse(text); }
  catch { return alert('Not a valid JSON map file'); }

  /* ---------- wipe current scene ---------- */
  ['#handles-layer *', '#lines-layer *', '#markers-layer *']
    .forEach(sel => document.querySelectorAll(sel).forEach(el => el.remove()));
  svg.querySelectorAll('path').forEach(p => p.remove());
  imgTriggers.length = 0;                          // clear runtime registry

  /* ---------- restore zones ---------- */
  (data.zones || []).forEach(z => {
    const p = document.createElementNS(svg.namespaceURI, 'path');
    p.id = z.id;
    p.dataset.label = z.label;
    if (z.color) p.style.fill = z.color;
    p.setAttribute('d', verticesToPath(z.vertices));
    mapContent.insertBefore(p, handlesLayer);
    p.addEventListener('click',       () => selectZone(p));
    p.addEventListener('pointerdown', startZoneMove);
  });

  /* ---------- restore markers ---------- */
  (data.markers || []).forEach(m => {
    const SIZE = MARKER_SIZE;
    const mid = `m-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;

    const marker = document.createElementNS(svg.namespaceURI, 'circle');
    marker.setAttribute('cx', m.cx);
    marker.setAttribute('cy', m.cy);
    marker.setAttribute('r',  m.radius || 10);
    marker.setAttribute('fill', '#f59e0b');
    marker.setAttribute('stroke', '#000');
    marker.setAttribute('stroke-width', 2);
    marker.classList.add('map-marker');
    marker.dataset.label = m.label;
    marker.dataset.icon  = m.icon || '';
    document.getElementById('markers-layer').appendChild(marker);
    marker.dataset.mid = mid;

    if (m.icon) {
      const img = document.createElementNS(svg.namespaceURI, 'image');
      img.setAttributeNS(null, 'href', m.icon);
      img.setAttribute('x', m.cx - SIZE/2);
      img.setAttribute('y', m.cy - SIZE/2);
      img.setAttribute('width',  SIZE);
      img.setAttribute('height', SIZE);
      img.classList.add('marker-icon');
      img.dataset.mid = mid
      document.getElementById('markers-layer').appendChild(img);
    }

    const t = document.createElementNS(svg.namespaceURI, 'text');
    t.setAttribute('x', m.cx + 20);
    t.setAttribute('y', m.cy + 6);
    t.setAttribute('font-size', '16');
    t.setAttribute('fill', '#111');
    t.textContent = m.label;
    t.dataset.mid = mid;
    document.getElementById('markers-layer').appendChild(t);
  });

  /* ---------- restore text boxes ---------- */
  (data.textboxes || []).forEach(tb => {
    const g = document.createElementNS(svg.namespaceURI, 'g');
    g.classList.add('map-textbox');

    const t = document.createElementNS(svg.namespaceURI, 'text');
    t.setAttribute('x', tb.x);
    t.setAttribute('y', tb.y);
    t.setAttribute('font-size', '16');
    t.setAttribute('fill', '#111');
    t.textContent = tb.text;
    g.appendChild(t);
    document.getElementById('markers-layer').appendChild(g);
  });

  /* ---------- restore image triggers ---------- */
  (data.images || []).forEach(I => {
    const img = document.createElementNS(svg.namespaceURI, 'image');
    img.setAttributeNS(null, 'href', I.url);
    img.setAttribute('x', I.x - I.width/2);
    img.setAttribute('y', I.y - I.height/2);
    img.setAttribute('width',  I.width);
    img.setAttribute('height', I.height);
    img.classList.add('img-trigger');
    makeTriggerDeletable(img); 
    document.getElementById('markers-layer').appendChild(img);

    imgTriggers.push({
      x : I.x,
      y : I.y,
      el: img,
      active: false,
      hideTimer: null
    });
  });

  /* ---------- restore lines ---------- */
  (data.lines || []).forEach(L => {
    const ghost = document.createElementNS(svg.namespaceURI, 'line');
    ghost.id = L.id;
    ['x1','y1','x2','y2'].forEach(a => ghost.setAttribute(a, L[a]));
    ghost.setAttribute('stroke', 'transparent');
    ghost.setAttribute('stroke-width', 20);
    ghost.setAttribute('pointer-events', 'stroke');
    ghost._dots = [];
    document.getElementById('lines-layer').appendChild(ghost);

    /* dots */
    (L.dots || []).forEach(({cx,cy}) => {
      const d = document.createElementNS(svg.namespaceURI, 'circle');
      d.setAttribute('cx', cx);
      d.setAttribute('cy', cy);
      d.setAttribute('r', 6);
      d.setAttribute('fill', '#fff');
      d.setAttribute('stroke', '#000');
      d.setAttribute('stroke-width', 2);
      d.classList.add('map-line-dot');
      d.dataset.parentLine = L.id;
      ghost._dots.push(d);
      document.getElementById('lines-layer').appendChild(d);
    });

    /* endpoint handles */
    const h1 = createLineHandle(L.x1, L.y1, ghost, 'x1', 'y1');
    const h2 = createLineHandle(L.x2, L.y2, ghost, 'x2', 'y2');
    handlesLayer.appendChild(h1);
    handlesLayer.appendChild(h2);
  });

  /* ---------- settings ---------- */
  document.getElementById('toggle-lines').checked = data.settings?.showLines !== false;

  renderAllDistances();
  refreshMarkerDropdowns();
  updateLineVisibility();
  setStatus('<em>Map imported successfully.</em>');
}

function generateAllPaths() {
  // 1. list all marker labels that exist right now
  const labels = [...document.querySelectorAll('#markers-layer circle')]
                 .map(c => c.dataset.label)
                 .filter(Boolean);

  // 2. build every ordered pair  (A ‚ûú B,   B ‚ûú A)
  const routes = [];
  for (let i = 0; i < labels.length; i++) {
    for (let j = 0; j < labels.length; j++) {
      if (i === j) continue;                     // skip A ‚ûú A
      const path = shortestPath(labels[i], labels[j]);
      if (path) {                               // reachable?
        routes.push({
          Source      : labels[i],
          Destination : labels[j],
          Passby      : path                    // full label sequence
        });
      }
    }
  }
  return routes;
}





/********* Initial attach *********/
svg.querySelectorAll('path').forEach(p=>{p.addEventListener('click',()=>selectZone(p));p.addEventListener('pointerdown',startZoneMove);});
svg.addEventListener('pointermove',onPointerMove);
svg.addEventListener('pointerup',endDrag);
svg.addEventListener('mousedown',onSvgLeftClick);
svg.addEventListener('contextmenu',onSvgRightClick);
svg.addEventListener('pointerup', (e) => {
  const pt = svgPoint(e);
  
  if (imgAddMode && e.button === 0){
    const { url } = imgAddMode;        // keep the URL
    imgAddMode  = false;              // ‚ë† turn the mode OFF first
    const p   = mapPoint(e);           // ‚ë° now create the trigger
    const img = addImgTrigger(p.x, p.y, url);
    img.classList.add('preview');
    setTimeout(() => img.classList.remove('preview'), 2000);                     // reset the tool
    setStatus('<em>Select a zone to view details.</em>');
    return;                                        // skip rest of handler
  }

  if (textMode && e.button === 0) {
    const txt = prompt("Text to display:");
    if (!txt) { textMode = false; return; }

    const g = document.createElementNS(svg.namespaceURI, 'g');
    g.classList.add('map-textbox');
    
    const t = document.createElementNS(svg.namespaceURI, 'text');
    t.setAttribute('x', pt.x);
    t.setAttribute('y', pt.y);
    t.setAttribute('font-size', '16');
    t.setAttribute('fill', '#111');
    t.textContent = txt;
    
    g.appendChild(t);
    document.getElementById('markers-layer').appendChild(g);

    /* make it draggable with middle-button (reuse your current pattern) */
    g.addEventListener('pointerdown', (ev) => {
      if (ev.button !== 1) return;+      
      ev.stopPropagation();
      dragMode = 'textbox';
     dragButton = 1;
     currentHandle = g;                          // recycle this var
      startPt = mapPoint(ev);
      g.setPointerCapture(ev.pointerId);
    });

    /* allow deletion when markerDeleteMode is active */
    g.addEventListener('click', () => {
      if (markerDeleteMode) g.remove();
    });

    textMode = false;
    setStatus('<em>Select a zone to view details.</em>');
    return;                         // don‚Äôt run marker / line logic below
  }
  // üî∂ 1. Handle placing a marker
  if (markerMode && e.button === 0) {
    const label = prompt("Enter marker label:");
    const mid = `m-${Date.now()}`;
    if (!label) {
      markerMode = false;
      return;
    }

    const iconURL = document.getElementById('marker-icon').value;
    const SIZE    = MARKER_SIZE;

    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    marker.setAttribute('cx', pt.x);
    marker.setAttribute('cy', pt.y);
    marker.setAttribute('r', MARKER_RADIUS);
    marker.setAttribute('fill', '#f59e0b');
    marker.setAttribute('stroke', '#000');
    marker.setAttribute('stroke-width', 2);
    marker.dataset.label = label;
    marker.classList.add('map-marker');
    marker.dataset.icon  = iconURL;
    marker.dataset.mid   = mid;

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', pt.x + 20);
    text.setAttribute('y', pt.y + 6);
    text.setAttribute('font-size', '16px');
    text.setAttribute('fill', '#111');
    text.textContent = label;
    text.dataset.mid   = mid;

    document.getElementById('markers-layer').appendChild(marker);

    const img = document.createElementNS(svg.namespaceURI,'image');
    img.setAttributeNS(null,'href', iconURL);
    img.setAttribute('x', pt.x - SIZE/2);
    img.setAttribute('y', pt.y - SIZE/2);
    img.setAttribute('width',  SIZE);
    img.setAttribute('height', SIZE);
    img.classList.add('marker-icon');       // CSS prevents mouse-grab
    img.dataset.mid   = mid;
    document.getElementById('markers-layer').appendChild(img);
    document.getElementById('markers-layer').appendChild(text);

    markerMode = false;
    setStatus('<em>Select a zone to view details.</em>');
    refreshMarkerDropdowns();
    buildIconPicker(); 
    return;  // prevent line logic below
  }

  // üî∑ 2. Handle line drawing (existing logic)
  if (!lineMode || dragMode || e.button !== 0) return;

  let snapPt = getNearestSnapPoint(pt);
  const dist = Math.hypot(snapPt.x - pt.x, snapPt.y - pt.y);
  if (dist > CLOSE_THRESHOLD) snapPt = pt;   // keep your old guard

  if (!lineStart) {
    lineStart = snapPt;
    linePreview.setAttribute('x1', snapPt.x);
    linePreview.setAttribute('y1', snapPt.y);
    linePreview.setAttribute('x2', snapPt.x);
    linePreview.setAttribute('y2', snapPt.y);
    linePreview.setAttribute('visibility', 'visible');
  } else {
    drawLine(lineStart, snapPt);
    lineStart = null;
    linePreview.setAttribute('visibility', 'hidden');
  }
});
svg.addEventListener('contextmenu', (e) => {
  if (lineMode && lineStart) {
    e.preventDefault();
    lineStart = null;
  }
});
svg.addEventListener('contextmenu', (e) => {
  if (lineMode && lineStart) {
    e.preventDefault();
    lineStart = null;
    linePreview.setAttribute('visibility', 'hidden');
  }
});
addBtn.addEventListener('click',beginDraw);
cancelBtn.addEventListener('click',cancelDraw);
exportBtn.addEventListener('click',exportJSON);
deleteBtn.addEventListener('click',deleteZone);
window.addEventListener('mousedown', (e) => {
  if (e.button === 1) e.preventDefault(); // prevent auto-scroll on middle click
});
lineBtn.addEventListener('click', () => {
  lineMode = !lineMode;
  lineStart = null;
  lineBtn.textContent = lineMode ? 'Cancel Line' : 'Add Line';

  // Disable zone drawing while in line mode
  if (lineMode) {
    dragMode = null;
    cancelBtn.disabled = true;
    addBtn.disabled = false;
  }
});
document.getElementById('toggle-distances').addEventListener('change', (e) => {
  if (e.target.checked) {
    renderAllDistances();
  } else {
    distanceLayer.innerHTML = '';
  }
});
document.getElementById('marker-btn').addEventListener('click', () => {
  markerMode = true;
  setStatus('<strong>Click on the map to place a marker</strong>');
});
document.getElementById('find-path-btn').addEventListener('click', () => {
  const from = document.getElementById('from-marker').value;
  const to   = document.getElementById('to-marker').value;
  if (!from || !to || from === to) return alert('Select two different markers');

  const labelsPath = shortestPath(from, to);
  if (!labelsPath) {
    alert('No path found between those markers');
  } else {
    highlightPath(labelsPath);
  }
});
document.getElementById('clear-path-btn').addEventListener('click', clearHighlight);
document.getElementById('toggle-lines').addEventListener('change', () => {
          clearHighlight();          // remove old highlight colour
          updateLineVisibility();    // then apply visibility rule
        });
document.getElementById('import-file').addEventListener('change', e => {
  const file = e.target.files[0];
  importJSON(file);
  e.target.value = '';          // allow re-importing same file
});
document.getElementById('import-btn').addEventListener('click', () =>
  document.getElementById('import-file').click()
);
document.getElementById('delete-line-btn').addEventListener('click', () => {
  deleteLineMode = !deleteLineMode;
  document.getElementById('delete-line-btn').textContent = deleteLineMode ? 'Click Line to Delete' : 'Delete Line';
});
document.getElementById('delete-marker-btn').addEventListener('click', () => {
  markerDeleteMode = !markerDeleteMode;
  const btn = document.getElementById('delete-marker-btn');
  btn.classList.toggle('active', markerDeleteMode);
  btn.textContent = markerDeleteMode ? 'Cancel Marker Delete' : 'Delete Marker';
});
document.getElementById('export-paths-btn').addEventListener('click', () => {
  const data = generateAllPaths();
  const blob = new Blob([JSON.stringify(data, null, 2)],
                        { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'all_paths.json';
  a.click();
  URL.revokeObjectURL(a.href);
});
document.getElementById('fill-color').addEventListener('input', (e) => {
  if (currentZone) {
    const color = e.target.value;
    currentZone.setAttribute('fill', color);        // Optional: for export
    currentZone.style.fill = color;                 // Force visual update
  }
});
document.getElementById('textbox-btn').addEventListener('click', () => {
  textMode = true;
  setStatus('<strong>Click on the map to place a text box</strong>');
});
document.getElementById('add-img-btn').addEventListener('click', () =>
  document.getElementById('img-file').click()
);
document.getElementById('img-file').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;

  /* ------ decide the path you want to write to the SVG ------ */
  const relPath = `assets/img/${file.name}`;              // <‚Äì‚Äì your folder

  /* (scope) store it for the upcoming pointer-up */
  imgAddMode = { url: relPath };

  /* optional ‚Äì preview the local file so the user sees something
     before the build process copies it to assets/img/ ‚Ä¶ */
  const blobUrl = URL.createObjectURL(file);
  imgPreview.src = blobUrl;                               // if you have one

  setStatus('<strong>Click on the map to place the image</strong>');
});

/* ---------- apply geometry constants to the SVG once ---------- */
svg.setAttribute("viewBox", `0 0 ${MAP_W} ${MAP_H}`);
frame.setAttribute("x",      MARGIN);
frame.setAttribute("y",      MARGIN);
frame.setAttribute("width",  MAP_W - 2*MARGIN);
frame.setAttribute("height", MAP_H - 2*MARGIN);
clip.setAttribute("x",      MARGIN);
clip.setAttribute("y",      MARGIN);
clip.setAttribute("width",  MAP_W - 2*MARGIN);
clip.setAttribute("height", MAP_H - 2*MARGIN);

svg.addEventListener("wheel", (e) => {
  e.preventDefault();
  const dz = e.deltaY > 0 ? -0.1 : 0.1;           // scroll-up = zoom in
  zoom = Math.min(3, Math.max(0.3, zoom + dz));   // clamp 0.3 ‚Ä¶ 3
  applyTransform();
});
svg.addEventListener("pointerdown", (e) => {
  if (e.button !== 1) return;                     // middle-button only
  panning = true;
  lastSVG = mapPoint(e);                          // store start pos (SVG space)
  svg.setPointerCapture(e.pointerId);             // keep moves even off map
  e.preventDefault();                             // block default scroll
});
svg.addEventListener("pointermove", (e) => {
  if (!panning) return;                  // ‚Üê only pan while mid-button held
  e.stopImmediatePropagation();
  const m = mapContent.getScreenCTM();   // current transform matrix
  panX += e.movementX / m.a;             // m.a and m.d are the X/Y scales
  panY += e.movementY / m.d;
  applyTransform();  
});
svg.addEventListener("pointerup", () => {          // middle-button released
  panning = false;
});
svg.addEventListener("pointercancel", () => {      // capture lost
  panning = false;
});


let imgIdCounter = 0;                    // put near the other counters

function addImgTrigger(x, y, url, w = IMAGE_SIZE, h = IMAGE_SIZE){
  const img = document.createElementNS(svg.namespaceURI, 'image');
  img.setAttributeNS(null, 'href', url);
  img.setAttribute('x', x - w / 2);
  img.setAttribute('y', y - h / 2);
  img.setAttribute('width',  w);
  img.setAttribute('height', h);
  img.classList.add('img-trigger');
  img.style.pointerEvents = 'auto';      // clickable even if CSS kept

  /* allow deletion while ‚Äúdelete-marker‚Äù mode is on */
  img.addEventListener('click', () => {
    if (!imgDeleteMode) return;
    deleteImgTrigger(img.dataset.tid);
  });

  const id = `img-${++imgIdCounter}`;
  img.dataset.tid = id;                 // keep id on the element
  document.getElementById('markers-layer').appendChild(img);

  imgTriggers.push({ id, x, y, el: img, active:false, hideTimer:null });
  makeTriggerDeletable(img); 
  refreshImgTriggerList();              // keep drop-down in sync
  return img;
}

document.getElementById('toggle-invisible')
        .addEventListener('click', () => {
  showInvisible = !showInvisible;

  const btn = document.getElementById('toggle-invisible');
  btn.textContent = showInvisible
      ? 'üö´ Hide Hidden Images'
      : 'üëÅÔ∏è Show Hidden Images';

  imgTriggers.forEach(t => {
    if (showInvisible){
      // always show full-size
      t.el.style.opacity   = 1;
      t.el.style.transform = 'translate(-50%,-50%) scale(1)';
    }else if (!t.active){        // keep the one currently lit up
      t.el.style.opacity   = 0;
      t.el.style.transform = 'translate(-50%,-50%) scale(.12)';
    }
  });
});

function deleteImgTrigger(id){
  const idx = imgTriggers.findIndex(t => t.id === id);
  if (idx === -1) return false;

  imgTriggers[idx].el.remove();          // remove from DOM
  imgTriggers.splice(idx, 1);            // remove from registry
  refreshImgTriggerList();               // update <select>
  return true;
}


let imgDeleteMode = false;

document.getElementById('delete-img-btn')
        .addEventListener('click', () => {
  imgDeleteMode = !imgDeleteMode;

  const btn = document.getElementById('delete-img-btn');
  btn.textContent = imgDeleteMode
      ? '‚úÖ Deleting‚Ä¶ (click images)'
      : 'Delete Image Trigger';
});
function makeTriggerDeletable(img){
  img.addEventListener('click', () => {
    if (!imgDeleteMode) return;
    deleteImgTrigger(img.dataset.tid);
  });
}

const markersLayer = document.getElementById('markers-layer');

/* One listener: remove circle, label AND icon by shared mid */
markersLayer.addEventListener('click', (e) => {
  if (!markerDeleteMode) return;

  const circle = e.target.closest('circle.map-marker');
  if (!circle) return;                 // clicked something else

  const mid = circle.dataset.mid;      // shared id for this marker set
  markersLayer
    .querySelectorAll(`[data-mid='${mid}']`)
    .forEach(el => el.remove());

  refreshMarkerDropdowns();
});

/* ‚îÄ‚îÄ auto nodes for rogue line‚Äëendpoints ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const AUTO_NODE_PREFIX = 'P';   // will make labels  P1, P2, P3‚Ä¶
let   autoNodeCounter  = 0;

function getOrMakeNodeLabel(x, y, G) {
  // is there already a node here?
  for (const lbl in G) {
    if (Math.hypot(G[lbl].x - x, G[lbl].y - y) < CLOSE_THRESHOLD)
      return lbl;
  }
  // none ‚Äë‚ñ∫ create a synthetic one
  const lbl = `${AUTO_NODE_PREFIX}${++autoNodeCounter}`;
  G[lbl] = { x, y, neighbors: new Set() };
  return lbl;
}


</script>
</body>
</html>
